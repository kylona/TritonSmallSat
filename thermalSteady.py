import math
import random
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt

## MAJOR SATELLITE PARAMETERS ##
totalSurfaceArea = 7320 / 10000.0 #total surface area of satellite
totalSolarArea = 6600 / 10000.0 #total area of satellite made of solar panel
maxLitPanelArea = 2400 / 10000.0 #max area of solar panel in sun in m^2. (thought of as cm^2)
minLitPanelArea = 800 / 10000.0 #min area of solar panel in the sun
maxSunlightPercent = 100 # % of time in sunlight
minSunlightPercent = 60 # % of time in sunlight
otherArea = totalSurfaceArea - totalSolarArea #Non-solar-panel area

## MINOR SATELLITE PARAMETERS AND ASUMPTIONS ##
componantP = 15 # power lost to heat from provided componants
scat_maxP = 150 #max scaterometry power lost to heat
scat_minP = 50 #min scaterometry power lost to heat
radiometry_maxP = 10 #max radiometry power lost to heat
radiometry_minP = 3 #min radiometry power lost to heat
percentScatTime = 7/100.0 #percent of time we need to run scaterometry
percentOperating_max = 100/100.0 #The maximum amount of time we will operate
percentOperating_min = 50/100.0  #The minimum amount of time we will operate

## CONSTANTS AND TABULIZED VALUES ##
sunWPA_min = 1322 #minimum power from sunlight in watts per m^2
sunWPA_max = 1414 #maximum power from sunlight in watts per m^2
albedoWPA_min = 79 #minimum power reflected from earth in watts per m^2
albedoWPA_max = 707 #maximum power reflected from earth in watts per m^2
earthIRWPA_min = 108 #minimum power radiated from earth as infrared in watts per m^2
earthIRWPA_max = 332 #maximum power radiated from earth as infrared in watts per m^2
freeMolecular_o400 = 2.25 #heat generated from collision with free air molecules in watts per m^2
freeMolecular_o300 = 22.5 # ^ but at 300 km altitude
freeMolecular_o100 = 225 # ^ but at 100 km altitude
satMass = 100 #Arbitrary 0.1 kg weight (This does not effect steady state temp just how many steps to get there)
specificHeat = 0.900 #specific heat of aluminum (Does not effect steady state)
startTemp = 40 #Arbitrary start temp in degrees C (Does not effect steady state)
solarPanelAbsorbed = 0.7 #proportion of power from sunlight absorbed as heat by solar panels
                         #https://www.pveducation.org/pvcdrom/materials/optical-properties-of-silicon
otherAbsorbed = 0.01 #proportion of power from sunlight absorbed as heat by non-solar-panels
emissivitySolarPanels = 0.75 #http://eprints.gla.ac.uk/150163/
emissivityOther = 0.77 #Annodized https://www.engineeringtoolbox.com/emissivity-coefficients-d_447.html
stef_boltz = 5.6703e-8 #https://www.engineeringtoolbox.com/radiation-heat-transfer-d_431.html
spaceTempK = 2.73 #From google temperature of space in Kelvin

## ACCURACY OF STEADY STATE TEMPERATURE ##
juleEpsilon = 0.0001 #the minimum difference in heat energy considered significant

## Computes the amount of heat radiated in Watts of an area at a given temperature ##
def heatRadiated(temp, emissivity, area):
  tempK = temp + 273.15 #convert from C to K
  q = emissivity * stef_boltz * (math.pow(tempK,4) - math.pow(spaceTempK,4)) * area
  #https://www.engineeringtoolbox.com/radiation-heat-transfer-d_431.html
  return q

# Computes the maximum amount of heat generated by system componants ##
def componantHeatMax():
  deltaJules = scat_maxP * percentScatTime + radiometry_maxP * percentOperating_max + componantP
  return deltaJules

# Computes the minimum amount of heat generated by system componants ##
def componantHeatMin():
  deltaJules = scat_minP * percentScatTime + radiometry_minP * percentOperating_min + componantP
  return deltaJules
  
for sunlightPercent in range(minSunlightPercent,maxSunlightPercent + 1, 10):
  maxT = startTemp
  numSteps = 0;
  print "\nSunlight Percent: {}".format(sunlightPercent)
  sunlightPercent = sunlightPercent / 100.0
  heatIn =  (sunWPA_max + albedoWPA_max) * maxLitPanelArea * solarPanelAbsorbed * sunlightPercent
  heatIn += (sunWPA_max + albedoWPA_max) * otherArea * otherAbsorbed * sunlightPercent
  heatIn += earthIRWPA_max * (totalSurfaceArea/2)
  #asumption about half of the surface area faces the earth and 100% of radiated IR energy is absorbed
  heatIn += freeMolecular_o400 * (totalSurfaceArea/2)
  #asumption about half of the surface area faces direction of travel
  heatIn += componantHeatMax()
  while True:
     numSteps += 1
     #compute net change in jules
     deltaJules = heatIn
     deltaJules -= heatRadiated(maxT, emissivityOther, otherArea)
     deltaJules -= heatRadiated(maxT, emissivitySolarPanels, totalSolarArea)
     deltaT = deltaJules/(satMass*specificHeat) 
     maxT += deltaT
     #print("Temp at step {}: {} ({})".format(numSteps, str(maxT), deltaJules))
     if abs(deltaJules) < juleEpsilon: break
  print("Max Temperature: {} (found in {} steps)".format(maxT, numSteps))

  minT = startTemp
  numSteps = 0;
  heatIn = (sunWPA_min + albedoWPA_min) * minLitPanelArea * solarPanelAbsorbed * sunlightPercent
  heatIn += earthIRWPA_min * (totalSurfaceArea/2)
  #asumption about half of the surface area faces the earth and 100% of radiated IR energy is absorbed
  heatIn += freeMolecular_o400 * (totalSurfaceArea/2)
  #asumption about half of the surface area faces direction of travel
  heatIn += componantHeatMax()
  while True:
     numSteps += 1
     #compute net change in jules
     deltaJules = heatIn
     deltaJules -= heatRadiated(minT, emissivityOther, otherArea)
     deltaJules -= heatRadiated(minT, emissivitySolarPanels, totalSolarArea)
     deltaT = deltaJules/(satMass*specificHeat) 
     minT += deltaT
     #print("Temp at step {}: {} ({})".format(numSteps, str(minT), deltaJules))
     if abs(deltaJules) < juleEpsilon: break
  print("Min Temperature: {} (found in {} steps)".format(minT, numSteps))

#watts*time = q
#Jules/(mass*specificHeat) = delta(T)
